// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Collections;

namespace AssemblyCSharp
{
	public class RX_CardType
	{
		public RX_CardType ()
		{
		}

		#region 检测有效牌量..
		private static bool EffectiveNumber(RX_CardSet sender,int number)
		{
			return sender.Card_lister.Count == number;
		}
		private static bool EffectiveNumber(RX_CardSet sender,int minvalue,int maxvalue)
		{
			return sender.Card_lister.Count >= minvalue && sender.Card_lister.Count <= maxvalue;
		}
		#endregion

		#region 非空判断..

		private static bool NotNull(RX_CardSet sender)
		{
			return sender != null && sender.Card_lister != null;
		}

		#endregion

		#region 将牌型进行排序..
		private static void CardSetSort(RX_CardSet sender)
		{
			//从小到大的顺序..
			sender.Card_lister.Sort ((RX_Card x, RX_Card y) => {
				return (int)x.Level - (int)y.Level;	
			});
		}
		#endregion

		#region 牌个数是否是某个数字的整数倍..

		/// <summary>
		/// Determines if can be divided the specified sender divisor.
		/// </summary>
		/// <returns><c>true</c> if can be divided the specified sender divisor; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		/// <param name="divisor">Divisor.</param>
		private static bool CanBeDivided(RX_CardSet sender,int divisor)
		{
			return sender.Card_lister.Count % divisor == 0;
		}

		#endregion

		#region 某张是否是正常牌,非王,非2..

		private static bool IsNormal(RX_CardSet sender,int index)
		{
			RX_Card card = sender.Card_lister [index];

			return 
				card.Level != RX_CARD_LEVEL.RX_LEVEL_2 &&
				card.Level != RX_CARD_LEVEL.RX_LEVEL_S &&
				card.Level != RX_CARD_LEVEL.RX_LEVEL_B;
		}

		#endregion

		#region 两张牌是否相连..

		private static bool IsJoined(RX_CardSet sender,int l,int r)
		{
			if (r >= sender.Card_lister.Count) 
			{
				return true;
			}
			return (int)sender.Card_lister [l].Level - (int)sender.Card_lister [r].Level == -1;
		}

		#endregion

		#region 判断一个牌型是否都相同..

		/// <summary>
		/// Alls the is the same.
		/// </summary>
		/// <returns><c>true</c>, if is the same was alled, <c>false</c> otherwise.</returns>
		/// <param name="sender">Sender.</param>
		/// <param name="index">Index.</param>
		/// <param name="count">Count.</param>
		private static bool AllIsTheSame(RX_CardSet sender,int index,int count)
		{
			bool flag = true;

			for (int i = index; i < index + count - 1; i++) 
			{
				RX_Card l = sender.Card_lister [i];
				RX_Card r = sender.Card_lister [i + 1];

				if (l.Level != r.Level) 
				{
					flag = false;
					break;
				}
			}


			return flag;
		}

		#endregion


		#region 判断牌型区域..
		/// <summary>
		/// 如果是单牌,则修改对象属性..
		/// </summary>
		/// <returns><c>true</c> if is dan the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsDan (RX_CardSet sender)
		{
			if (NotNull (sender) && EffectiveNumber (sender, 1)) 
			{
				sender.Card_type = RX_CARD_SET.RX_TYPE_DAN;
				sender.Card_level = (sender.Card_lister [0]).Level;

				return true;
			}

			return false;
		}

		/// <summary>
		/// Determines if is dui the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is dui the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsDui(RX_CardSet sender)
		{
			if (NotNull(sender) && EffectiveNumber(sender,2) && AllIsTheSame(sender,0,2)) 
			{
				sender.Card_type = RX_CARD_SET.RX_TYPE_DUI;
				sender.Card_level = sender.Card_lister [0].Level;

				return true;
			}

			return false;
		}
		/// <summary>
		/// Determines if is san bu dai the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is san bu dai the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsSanBuDai(RX_CardSet sender)
		{
			if (NotNull (sender) && EffectiveNumber (sender, 3) && AllIsTheSame (sender, 0, 3)) {
				sender.Card_type = RX_CARD_SET.RX_TYPE_SAN_BUDAI;
				sender.Card_level = sender.Card_lister [0].Level;
				return true;
			}
			return false;

		}
		/// <summary>
		/// Determines if is boom the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is boom the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsBoom(RX_CardSet sender)
		{
			if (NotNull (sender) && EffectiveNumber (sender, 4) && AllIsTheSame (sender, 0, 4)) 
			{
				sender.Card_type = RX_CARD_SET.RX_TYPE_BOOM;
				sender.Card_level = sender.Card_lister [0].Level;
				return true;
			}	
			return false;
		}

		/// <summary>
		/// Determines if is big boom the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is big boom the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsBigBoom(RX_CardSet sender)
		{
			if (NotNull(sender) && EffectiveNumber(sender,2)) {

				//王炸的Card_level值...
				int target_Card_level = (int)RX_CARD_LEVEL.RX_LEVEL_B + (int)RX_CARD_LEVEL.RX_LEVEL_S;

				//当前牌型的Card_level值...
				int current_Card_level = (int)sender.Card_lister[0].Level + (int)sender.Card_lister[1].Level;

				if (target_Card_level == current_Card_level) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_WANGZHA;
					return true;
				}
			}

			return false;
		}

		/// <summary>
		/// Determines if is lian dui the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is lian dui the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsLianDui(RX_CardSet sender)
		{
			if (NotNull(sender) && EffectiveNumber(sender,6,20) && CanBeDivided(sender,2)) 
			{
				//将牌型进行排序..
				CardSetSort (sender);

				//33445566

				//34556677

				//33558899

				//KKAA22

				//计算出有n对..
				int n = sender.Card_lister.Count / 2;

				//遍历n对..
				for (int i = 0; i < n; i++) 
				{
					//34556677
					if (!AllIsTheSame(sender,i * 2,2)) 
					{
						return false;
					}

					//KKAA22
					if (!IsNormal(sender,i * 2)) 
					{
						return false;
					}

					//01234567
					//33558899
					if (!IsJoined(sender,i * 2,i * 2 + 2)) {
						return false;
					}
				}

				sender.Card_type = RX_CARD_SET.RX_TYPE_LIANDUI;
				sender.Card_level = sender.Card_lister[0].Level;
				return true;
			}

			return false;
		}

		//右边的写顺子和三带一..
		//中间的写飞机不带和四带二..
		//左边的写飞机带..

		//飞机带、四带二..

		/// <summary>
		/// Determines if is shunzi the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is shunzi the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsShunzi(RX_CardSet sender)
		{
			if (NotNull(sender) && EffectiveNumber(sender,5,12)) {

				int count = sender.Card_lister.Count;

				//根据级别进行拍讯..
				CardSetSort (sender);

				for (int i = 0; i < count - 1; i++) 
				{
					if (!IsNormal(sender, i) || !IsNormal(sender, i + 1) || !IsJoined(sender, i, i + 1)) 
					{
						return false;
					}
				}

				sender.Card_type = RX_CARD_SET.RX_TYPE_SHUN;
				sender.Card_level = sender.Card_lister[0].Level;
				return true;
			}

			return false;
		}

		/// <summary>
		/// Determines if is sandaiyi the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is sandaiyi the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsSandaiyi(RX_CardSet sender)
		{

			if (NotNull(sender) && EffectiveNumber(sender,4)) {

				//排序...
				CardSetSort (sender);

				if (AllIsTheSame(sender,0,4)) {
					return false;
				}

				if (AllIsTheSame(sender,0,3) ) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SAN_DAI;
					sender.Card_level = sender.Card_lister[0].Level;
					return true;
				}

				if (AllIsTheSame(sender,1,3)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SAN_DAI;
					sender.Card_level = sender.Card_lister[1].Level;
					return true;
				}
			}

			if (NotNull(sender) && EffectiveNumber(sender,5)) {

				//排序...
				CardSetSort (sender);

				if (AllIsTheSame(sender,0,4) || AllIsTheSame(sender,1,4)) 
				{
					return false;
				}

				if (AllIsTheSame(sender,0,3) && AllIsTheSame(sender,3,2)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SAN_DAI;
					sender.Card_level = sender.Card_lister[0].Level;
					return true;
				}

				if (AllIsTheSame(sender,0,2) && AllIsTheSame(sender,2,3)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SAN_DAI;
					sender.Card_level = sender.Card_lister[2].Level;
					return true;
				}
			}

			return false;
		}

		/// <summary>
		/// Determines if is feijibudai the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is feijibudai the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsFeijibudai(RX_CardSet sender)
		{
            CardSetSort(sender);
			if (NotNull(sender) && EffectiveNumber(sender,6,20) && CanBeDivided(sender,3)) 
			{
				int n = sender.Card_lister.Count / 3;

				for (int i = 0; i < n; i++) 
				{
					//334555667
					if (!AllIsTheSame(sender,i * 3,3)) 
					{
						return false;
					}

					//AAA222
					if (!IsNormal(sender,i * 3)) {
						return false;
					}

					//333555
					if (!IsJoined(sender,i * 3,i * 3 + 3)) {
						return false;
					}
				}
				sender.Card_type = RX_CARD_SET.RX_TYPE_FEI_BUDAI;
				sender.Card_level = sender.Card_lister[0].Level;
				return true;
			}
			return false;
		}

		/// <summary>
		/// Determines if is feijidai the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is feijidai the specified sender; otherwise, <c>false</c>..</returns>
		/// <param name="sender">Sender..</param>
		public static bool IsFeijidai(RX_CardSet sender)
		{
			if (NotNull(sender) && EffectiveNumber(sender,8,20)) 
			{
				Dictionary<RX_CARD_LEVEL,int> dictionary= new Dictionary<RX_CARD_LEVEL, int> ();

				//按大小给牌分组..
				for (int i = 0;i < sender.Card_lister.Count; i++) 
				{
					RX_Card card = sender.Card_lister [i];

					int count = 0;
					if (dictionary.ContainsKey(card.Level)) 
					{
						dictionary.TryGetValue(card.Level,out count);

						count += 1;

						//大于3时,直接失败..
						if (count > 3) {
							return false;
						}

						dictionary [card.Level] = count;
					}
					else
					{
						//如果在字典中还没有这个大小的牌,则新加入一个记录..
						dictionary.Add(card.Level,1);
					}
				}

				//按三张和非三张给牌分组..
				List<RX_CARD_LEVEL> three_Card_level_list = new List<RX_CARD_LEVEL> ();
				List<int> other_Card_level_list = new List<int> ();

				foreach (RX_CARD_LEVEL Card_level in dictionary.Keys) 
				{
					int count = 0;

					dictionary.TryGetValue (Card_level, out count);

					if (count == 3) {
						three_Card_level_list.Add (Card_level);
					} else {
						other_Card_level_list.Add (count);
					}
				}

				//如果飞机中三张相同大小的牌的个数和要带的牌大小的个数不一样,直接返回false..
				//444555666 778899..
				if (three_Card_level_list.Count != dictionary.Keys.Count / 2) 
				{
					return false;
				}

				//如果不同的牌的张数不一样,返回假..
				//情况444555666  ->(778899)<- 保证张数是 2 2 2 或 1 1 1..
				for (int i = 0; i < other_Card_level_list.Count - 1; i++) 
				{
					if (other_Card_level_list[i] != other_Card_level_list[i + 1]) {
						return false;
					}
				}

				//保证三张相同的牌的各个是相连的..
				for (int i = 0; i < three_Card_level_list.Count - 1; i++) 
				{
					if ((int)three_Card_level_list[i] - (int)three_Card_level_list[i + 1] != -1) 
					{
						return false;
					}
				}

				sender.Card_type = RX_CARD_SET.RX_TYPE_FEI_DAI;
				sender.Card_level = three_Card_level_list[0];

				return true;
			}

			return false;
		}

		/// <summary>
		/// Determines if is sidaier the specified sender.
		/// </summary>
		/// <returns><c>true</c> if is sidaier the specified sender; otherwise, <c>false</c>.</returns>
		/// <param name="sender">Sender.</param>
		public static bool IsSidaier(RX_CardSet sender)
		{
			if (NotNull(sender) && EffectiveNumber(sender,6)) 
			{
				//paixu
				CardSetSort(sender);

				//四个不能带一对..
				if (AllIsTheSame(sender,0,4) && !AllIsTheSame(sender,4,2)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SIDAIER;
					sender.Card_level = sender.Card_lister[0].Level;
					return true;
				}

				if (AllIsTheSame(sender,1,4)) {
					sender.Card_type = RX_CARD_SET.RX_TYPE_SIDAIER;
					sender.Card_level = sender.Card_lister[1].Level;
					return true;
				}

				if (!AllIsTheSame(sender,0,2) && AllIsTheSame(sender,2,4)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SIDAIER;

					sender.Card_level = sender.Card_lister[2].Level;
					return true;
				}

				return false;
			}

			if (NotNull(sender) && EffectiveNumber(sender,8)) {

				CardSetSort(sender);

				//四张同牌在前面,	后四张不能全一样,必须是两队..
				if (AllIsTheSame(sender,0,4) && !AllIsTheSame(sender,4,4) && AllIsTheSame(sender,4,2) && AllIsTheSame(sender,6,2)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SIDAIER;
					sender.Card_level = sender.Card_lister[0].Level;
					return true;
				}

				if (AllIsTheSame(sender,0,2) && AllIsTheSame(sender,2,2) && !AllIsTheSame(sender,0,4) && AllIsTheSame(sender,4,4)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SIDAIER;
					sender.Card_level = sender.Card_lister[4].Level;
					return true;
				}

				if (AllIsTheSame(sender,0,2) && AllIsTheSame(sender,2,4) && AllIsTheSame(sender,6,2)) 
				{
					sender.Card_type = RX_CARD_SET.RX_TYPE_SIDAIER;
					sender.Card_level = sender.Card_lister[2].Level;
					return true;
				}

				return false;
			}

			return false;
		}

		#endregion
	}
}

